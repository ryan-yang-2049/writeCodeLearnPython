# -*- coding: utf-8 -*-

# __title__ = '09 封装.py'
# __author__ = 'yangyang'
# __mtime__ = '2018.03.19'

'''
•	掌握封装，封装与扩展性
•	掌握property

在python中用双下划线开头的方式将属性隐藏起来（设置成私有的）
    - 其实这仅仅这是一种变形操作
    - 类中所有双下划线开头的名称如__x都会自动变形成：_类名__x的形式：


封装不是单纯意义的隐藏
    封装有两种：
        1.封装数据属性。
        2.封装函数方法。隔离复杂度



封装不是单纯意义上的隐藏。
变量名或者方法名前面加上双下划线（“__”）就可以实现隐藏。就类定义阶段就会发生变形。
这种变形的特点：
    1、在类外部无法直接obj.__AttrName
    2、在类内部是可以直接使用：obj.__AttrName (在定义阶段已经正确访问了)
    3、子类无法覆盖父类__开头的属性
'''

class A(object):
    __x=1   #在类被定义的时候已经变形为：_A__x
    def __init__(self,name):
        self.__name = name  #变形为：_A__name

    def __foo(self): #变形为： _A__foo
        print('A.foo')

    def tell_info(self):
        print("隐藏的属性x:",self.__x)
        print("隐藏的属性name:",self.__name)

    def bar(self):
        print('A.bar')
        self.__foo() #变形为： self._A__foo()

class B(A):
    def __foo(self): #变形为： _B__foo
        print('B.foo')



# 操作1：查看隐藏的属性和正确调用隐藏属性
print(A.__dict__)

# 调用隐藏属性    对象._类名__属性
obj = A('ryan')
print(obj._A__x)    #这个只是调用隐藏属性的方法，但是在python中如果设置了隐藏属性，那就尽量不要在外部调用

print("obj.__dict__",obj.__dict__)  #{'_A__name': 'ryan'}


# 操作2：在内部可以正常使用隐藏的属性
obj.tell_info()
#结论：因此，在类内部是可以直接访问带有 “__”的属性的，因为隐藏属性在定义结束以后（类所有内容读取到内存以后）才会被变形，但是，在类内部就可以正常使用隐藏的属性



# 操作3：类定义完成以后设置的 “__” 的属性正常访问
obj.__age = 18
print(obj.__dict__) # {'_A__name': 'ryan', '__age': 18}

# 结论: 类里面的隐藏只有在类被定义的时候才会发生变形。如果在类被定义完成以后，已经变形结束了，此时如果在进行一次 “__X” 属性添加，那就是正常访问，并未被变形。


# 操作4：子类无法覆盖父类的 “__”开头的属性
b = B('ryan')
b.bar()
# 结论：之所会这样，是因为，在A类里面，self.__foo()  在类被定义的时候就已经把它给变形成为了 self._A__foo() 因此，此时调用就是调用A类里面的 __foo




